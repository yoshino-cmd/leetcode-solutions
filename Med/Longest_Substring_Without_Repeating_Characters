"""
📘 Problem: LeetCode 3 - Longest Substring Without Repeating Characters
🔗 https://leetcode.com/problems/longest-substring-without-repeating-characters/
✅ Difficulty: Medium

🧾 Description:
文字列 s が与えられたとき、重複する文字を含まない最長の「連続部分文字列（substring）」の長さを求める。

🧪 Examples:
Input:  s = "abcabcbb"
Output: 3    # "abc"

Input:  s = "bbbbb"
Output: 1    # "b"

Input:  s = "pwwkew"
Output: 3    # "wke"（"pwke" は subsequence なので不可）

🎯 Constraints:
- 0 <= s.length <= 5 * 10^4
- s は英数字・記号・空白を含む可能性あり

🧠 Approach（スライディングウィンドウ + 直近出現位置の辞書）:
- 左端 `left` と右端 `right` のウィンドウを動かし、各文字の「直近の次位置（index+1）」を `last` に記録
- s[right] がウィンドウ内に重複していれば、`left` を `max(left, last[s[right]])` にジャンプ
- その都度 `ans = max(ans, right - left + 1)` を更新
- 1パスで完了、インデックスの更新は O(1)

⏱ Time Complexity: O(n)
🗃 Space Complexity: O(min(n, Σ))  # Σ は文字集合のサイズ
"""

class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        last = {}       # char -> next index to place left (i.e., last position + 1)
        left = 0
        ans = 0

        for right, ch in enumerate(s):
            if ch in last:
                # ウィンドウ左端を、重複しない位置までスキップ
                left = max(left, last[ch])
            # 現在文字 ch の「次に左端が来ても良い位置」を記録
            last[ch] = right + 1
            # ウィンドウ長を更新
            ans = max(ans, right - left + 1)

        return ans
